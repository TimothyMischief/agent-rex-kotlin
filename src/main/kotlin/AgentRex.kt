// This file is auto-generated by organjsm tangle. Do not edit directly.
// Source: index.org

// [[file:index.org::621]]
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.channels.*
import kotlinx.coroutines.flow.debounce as flowDebounce
import kotlinx.coroutines.flow.merge as flowMerge

/**
 * Creates a flow that emits a single value and then completes.
 */
fun <T> just(value: T): Flow<T> = flow {
    emit(value)
}

/** Alias for just */
fun <T> of(value: T): Flow<T> = just(value)
// unnamed ends here

// [[file:index.org::1042]]
/**
 * Creates a flow from a Deferred value.
 * When the Deferred completes, the flow emits the value and finishes.
 */
fun <T> fromDeferred(deferred: Deferred<T>): Flow<T> = flow {
  val value = deferred.await()
  emit(value)
}

/** Creates a flow from a suspend function */
fun <T> fromSuspend(block: suspend () -> T): Flow<T> = flow {
  val value = block()
  emit(value)
}
// unnamed ends here

// [[file:index.org::1372]]
/**
 * Creates a flow from an iterable.
 * Emits each value from the iterable in sequence.
 */
fun <T> from(iterable: Iterable<T>): Flow<T> = iterable.asFlow()

/**
 * Creates a flow from a sequence.
 */
fun <T> from(sequence: Sequence<T>): Flow<T> = sequence.asFlow()

/** Alias for from (iterable) */
fun <T> fromIterable(iterable: Iterable<T>): Flow<T> = from(iterable)
// unnamed ends here

// [[file:index.org::1737]]
/**
 * Creates a flow that emits Unit at regular intervals.
 * To give it a value, combine it with `constant`.
 */
fun periodic(intervalMs: Long): Flow<Unit> = flow {
  while (true) {
    emit(Unit)
    delay(intervalMs)
  }
}
// unnamed ends here

// [[file:index.org::1994]]
/**
 * Creates a flow that immediately completes without emitting any values.
 */
fun <T> empty(): Flow<T> = emptyFlow()
// unnamed ends here

// [[file:index.org::2221]]
/**
 * Creates a flow that never emits any values and never completes.
 * Suspends indefinitely until cancelled.
 */
fun <T> never(): Flow<T> = flow {
    awaitCancellation() // Suspends until cancelled
}
// unnamed ends here

// [[file:index.org::2509]]
/**
 * Creates a flow that emits an infinite sequence by repeatedly applying a function.
 */
fun <T> iterate(seed: T, fn: (T) -> T): Flow<T> = flow {
  var current = seed
  while (true) {
    emit(current)
    current = fn(current)
  }
}
// unnamed ends here

// [[file:index.org::2894]]
/**
 * Result of an unfold step.
 */
data class UnfoldResult<T, S>(
  val value: T,
  val nextSeed: S,
  val done: Boolean
)

/**
 * Creates a flow by unfolding a seed value.
 * The function returns an object containing the next value, next seed, and done flag.
 */
fun <T, S> unfold(seed: S, fn: (S) -> UnfoldResult<T, S>): Flow<T> = flow {
  var currentSeed = seed
  while (true) {
    val result = fn(currentSeed)
    if (result.done) break
    emit(result.value)
    currentSeed = result.nextSeed
  }
}
// unnamed ends here

// [[file:index.org::3284]]
/**
 * Prepends a value to the beginning of a stream.
 */
fun <T> startWith(value: T, stream: Flow<T>): Flow<T> = flow {
  emit(value)
  emitAll(stream)
}
// unnamed ends here

// [[file:index.org::3588]]
/**
 * Concatenates multiple streams into a single stream.
 */
fun <T> concat(vararg streams: Flow<T>): Flow<T> = flow {
  for (stream in streams) {
    emitAll(stream)
  }
}

/**
 * Concatenates two streams.
 */
fun <T> concat2(s1: Flow<T>, s2: Flow<T>): Flow<T> = flow {
  emitAll(s1)
  emitAll(s2)
}
// unnamed ends here

// [[file:index.org::4500]]
/**
 * Transforms each value emitted by a flow using a provided function.
 * Kotlin's Flow.map is already built-in, this is a wrapper for consistency.
 */
fun <T, U> Flow<T>.mapStream(fn: (T) -> U): Flow<U> = map(fn)

/**
 * Transforms each value with a suspend function (async mapper).
 */
fun <T, U> Flow<T>.mapAsync(fn: suspend (T) -> U): Flow<U> = map { fn(it) }
// unnamed ends here

// [[file:index.org::4882]]
/**
 * Emits a constant value for each item in the source flow.
 */
fun <T, U> Flow<T>.constant(value: U): Flow<U> = map { value }
// unnamed ends here

// [[file:index.org::5206]]
/**
 * Accumulates values using an accumulator function, emitting each intermediate result.
 * Yields the seed first, then each accumulated value.
 */
fun <T, U> Flow<T>.scanWithSeed(initial: U, operation: suspend (acc: U, value: T) -> U): Flow<U> = flow {
  var accumulator = initial
  emit(accumulator)
  collect { value ->
    accumulator = operation(accumulator, value)
    emit(accumulator)
  }
}
// unnamed ends here

// [[file:index.org::5642]]
/**
 * Performs side effects for each value without modifying them.
 * The side effect is fired without waiting.
 */
fun <T> tap(sideEffect: (T) -> Unit, stream: Flow<T>): Flow<T> = flow {
  stream.collect { value ->
    sideEffect(value)
    emit(value)
  }
}
// unnamed ends here

// [[file:index.org::5959]]
/**
 * Performs side effects for each value, awaiting completion before yielding.
 */
suspend fun <T> awaitTap(sideEffect: suspend (T) -> Unit, stream: Flow<T>): Flow<T> = flow {
  stream.collect { value ->
    sideEffect(value)
    emit(value)
  }
}
// unnamed ends here

// [[file:index.org::6314]]
/**
 * Continues a stream with another stream once the first completes.
 */
fun <T> continueWith(f: () -> Flow<T>, stream: Flow<T>): Flow<T> = flow {
  emitAll(stream)
  emitAll(f())
}
// unnamed ends here

// [[file:index.org::6654]]
/**
 * Flattens a stream of streams by concatenating them into a single stream.
 */
fun <T> concatAll(streamOfStreams: Flow<Flow<T>>): Flow<T> = flow {
  streamOfStreams.collect { innerStream ->
    emitAll(innerStream)
  }
}
// unnamed ends here

// [[file:index.org::6979]]
/**
 * Maps each value to a stream and concatenates the results in order.
 */
fun <T, U> concatMap(f: (T) -> Flow<U>, stream: Flow<T>): Flow<U> = flow {
  stream.collect { item ->
    emitAll(f(item))
  }
}
// unnamed ends here

// [[file:index.org::7362]]
/**
 * Filters values emitted by a flow based on a provided predicate function.
 * Kotlin's Flow.filter is already built-in, this is a wrapper for consistency.
 */
fun <T> Flow<T>.filterStream(predicate: (T) -> Boolean): Flow<T> = filter(predicate)

/**
 * Filters with a suspend predicate (async filter).
 */
fun <T> Flow<T>.filterAsync(predicate: suspend (T) -> Boolean): Flow<T> = filter { predicate(it) }
// unnamed ends here

// [[file:index.org::7917]]
/**
 * Filters out consecutive duplicate values from a stream.
 */
fun <T> skipRepeats(stream: Flow<T>): Flow<T> = flow {
  var first = true
  var lastValue: T? = null
  stream.collect { item ->
    if (first || item != lastValue) {
      emit(item)
      lastValue = item
      first = false
    }
  }
}

/**
 * Filters out consecutive duplicates using a custom equality function.
 */
fun <T> skipRepeatsWith(equals: (T, T) -> Boolean, stream: Flow<T>): Flow<T> = flow {
  var first = true
  var lastValue: T? = null
  stream.collect { item ->
    if (first || !equals(item, lastValue!!)) {
      emit(item)
      lastValue = item
      first = false
    }
  }
}
// unnamed ends here

// [[file:index.org::8381]]
/**
 * Takes only the first n values from a flow.
 * Kotlin's Flow.take is already built-in, this is a wrapper for consistency.
 */
fun <T> Flow<T>.takeStream(n: Int): Flow<T> = take(n)
// unnamed ends here

// [[file:index.org::8722]]
/**
 * Skips the first n values from a flow.
 * Note: In Kotlin Flow, this is called 'drop'.
 */
fun <T> Flow<T>.skip(n: Int): Flow<T> = drop(n)
// unnamed ends here

// [[file:index.org::9090]]
/**
 * Emits values from index start to end (exclusive).
 */
fun <T> slice(start: Int, end: Int, stream: Flow<T>): Flow<T> = flow {
  var index = 0
  stream.collect { item ->
    if (index >= start && index < end) {
      emit(item)
    }
    index++
    if (index >= end) {
      return@collect
    }
  }
}
// unnamed ends here

// [[file:index.org::9492]]
/**
 * Takes values from a stream while the predicate returns true.
 */
suspend fun <T> takeWhile(predicate: suspend (T) -> Boolean, stream: Flow<T>): Flow<T> = flow {
  stream.takeWhile { predicate(it) }.collect { emit(it) }
}
// unnamed ends here

// [[file:index.org::9888]]
/**
 * Skips values while the predicate returns true, then emits the rest.
 */
fun <T> skipWhile(predicate: suspend (T) -> Boolean, stream: Flow<T>): Flow<T> = flow {
  stream.dropWhile { predicate(it) }.collect { emit(it) }
}
// unnamed ends here

// [[file:index.org::10270]]
/**
 * Takes values until the predicate matches (matching value not emitted).
 */
fun <T> takeUntil(predicate: (T) -> Boolean, stream: Flow<T>): Flow<T> = flow {
  var shouldStop = false
  stream.collect { item ->
    if (shouldStop) return@collect
    if (predicate(item)) {
      shouldStop = true
      return@collect
    }
    emit(item)
  }
}

// Note: Flow doesn't have a forEach that can break, so we use a workaround
suspend fun <T> takeUntilSuspend(predicate: suspend (T) -> Boolean, stream: Flow<T>): Flow<T> = flow {
  stream.takeWhile { !predicate(it) }.collect { emit(it) }
}
// unnamed ends here

// [[file:index.org::10719]]
/**
 * Delays each emission by the specified duration in milliseconds.
 */
fun <T> Flow<T>.delayEach(delayMs: Long): Flow<T> = flow {
  collect { value ->
    delay(delayMs)
    emit(value)
  }
}
// unnamed ends here

// [[file:index.org::11149]]
/**
 * Only emits a value if no new values arrive within the specified duration (in milliseconds).
 * Waits for the stream to "settle" before emitting.
 */
@OptIn(FlowPreview::class)
fun <T> Flow<T>.debounceEach(timeoutMillis: Long): Flow<T> =
  this.flowDebounce(timeoutMillis)
// unnamed ends here

// [[file:index.org::11795]]
data class ThrottleOptions(
  val leading: Boolean = true,
  val trailing: Boolean = true
) {
  companion object {
    fun leadingOnly() = ThrottleOptions(leading = true, trailing = false)
    fun trailingOnly() = ThrottleOptions(leading = false, trailing = true)
  }
}

/**
 * Limits the rate of emissions with leading/trailing edge control.
 */
fun <T> Flow<T>.throttleEach(
  windowMs: Long,
  options: ThrottleOptions = ThrottleOptions()
): Flow<T> = flow {
  var lastEmitTime = 0L
  var trailingValue: T? = null
  var hasTrailing = false
  
  collect { item ->
    val now = System.currentTimeMillis()
    val elapsed = now - lastEmitTime
    
    if (elapsed >= windowMs) {
      if (options.leading) {
        emit(item)
        lastEmitTime = now
        hasTrailing = false
      } else {
        trailingValue = item
        hasTrailing = true
      }
    } else {
      trailingValue = item
      hasTrailing = true
    }
  }
  
  // Emit final trailing value if any
  if (hasTrailing && options.trailing) {
    trailingValue?.let { emit(it) }
  }
}
// unnamed ends here

// [[file:index.org::12421]]
/**
 * Recovers from errors by switching to an alternative stream.
 */
fun <T> Flow<T>.recoverWith(
  recoverFn: (Throwable) -> Flow<T>
): Flow<T> = this.catch { e -> emitAll(recoverFn(e)) }
// unnamed ends here

// [[file:index.org::12975]]
/**
 * Creates a stream that immediately throws an error when consumed.
 */
fun <T> throwError(error: Throwable): Flow<T> = flow {
  throw error
}
// unnamed ends here

// [[file:index.org::13469]]
data class RetryOptions(
  val maxAttempts: Int = 3,
  val delayMs: Long = 0,
  val shouldRetry: ((Throwable, Int) -> Boolean)? = null
)

/**
 * Retries a stream factory when it errors.
 */
suspend fun <T> retry(
  options: RetryOptions = RetryOptions(),
  streamFactory: () -> Flow<T>
): Flow<T> = flow {
  var attempt = 0
  
  while (true) {
    try {
      streamFactory().collect { emit(it) }
      return@flow // Success
    } catch (e: Throwable) {
      attempt++
      val shouldRetry = options.shouldRetry?.invoke(e, attempt) ?: true
      
      if (attempt >= options.maxAttempts || !shouldRetry) {
        throw e
      }
      
      if (options.delayMs > 0) {
        delay(options.delayMs)
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::14180]]
/**
 * Merges multiple flows into a single flow, emitting values as they arrive.
 */
fun <T> merge(vararg flows: Flow<T>): Flow<T> = flowMerge(*flows)

/**
 * Merges a list of flows into a single flow.
 */
fun <T> merge(flows: List<Flow<T>>): Flow<T> = flowMerge(*flows.toTypedArray())
// unnamed ends here

// [[file:index.org::14572]]
/**
 * Flattens a stream of streams by merging them into a single stream.
 */
fun <T> Flow<Flow<T>>.mergeAll(): Flow<T> = this.flattenMerge()
// unnamed ends here

// [[file:index.org::14991]]
/**
 * Maps each value to a flow and flattens the results concurrently.
 * Also known as chain in some libraries.
 */
fun <T, U> Flow<T>.chain(transform: suspend (T) -> Flow<U>): Flow<U> = 
  flatMapMerge { transform(it) }

/** Alias for chain */
fun <T, U> Flow<T>.flatMap(transform: suspend (T) -> Flow<U>): Flow<U> = 
  chain(transform)
// unnamed ends here

// [[file:index.org::15485]]
/**
 * Maps each value to a flow, cancelling the previous inner flow when a new value arrives.
 * Only values from the most recent inner flow are emitted.
 */
fun <T, U> Flow<T>.switchMap(transform: suspend (T) -> Flow<U>): Flow<U> =
  this.flatMapLatest { transform(it) }
// unnamed ends here

// [[file:index.org::15935]]
/**
 * Combines two flows, emitting tuples of latest values whenever either emits.
 * Only starts emitting after both flows have produced at least one value.
 */
fun <T, U> latest(flow1: Flow<T>, flow2: Flow<U>): Flow<Pair<T, U>> =
  flow1.combine(flow2) { a, b -> Pair(a, b) }
// unnamed ends here

// [[file:index.org::16259]]
/**
 * Applies the latest function to the latest value.
 */
fun <T, U> applyLatest(
  fnFlow: Flow<(T) -> U>,
  valueFlow: Flow<T>
): Flow<U> = latest(fnFlow, valueFlow).map { (fn, value) -> fn(value) }
// unnamed ends here

// [[file:index.org::16601]]
/**
 * Emits values from source until stop stream emits.
 */
suspend fun <T> Flow<T>.untilStream(stop: Flow<*>): Flow<T> = channelFlow {
  val stopSignal = Channel<Unit>(1)
  
  val stopJob = launch {
    stop.collect {
      stopSignal.send(Unit)
      stopSignal.close()
    }
  }
  
  try {
    collect { value ->
      if (stopSignal.tryReceive().isSuccess) {
        channel.close()
      } else {
        send(value)
      }
    }
  } finally {
    stopJob.cancel()
  }
}
// unnamed ends here

// [[file:index.org::16971]]
/**
 * Emits values from source only after start stream emits.
 */
suspend fun <T> Flow<T>.sinceStream(start: Flow<*>): Flow<T> = channelFlow {
  val startSignal = Channel<Unit>(1)
  
  val startJob = launch {
    start.collect {
      startSignal.send(Unit)
      startSignal.close()
    }
  }
  
  try {
    // Wait for start signal
    startSignal.receive()
    startJob.cancel()
    
    // Now emit all values
    collect { value -> send(value) }
  } finally {
    startJob.cancel()
  }
}
// unnamed ends here

// [[file:index.org::17328]]
/**
 * Collects values into lists of the specified size.
 */
fun <T> Flow<T>.buffer(size: Int): Flow<List<T>> = flow {
  val buf = mutableListOf<T>()
  collect { item ->
    buf.add(item)
    if (buf.size >= size) {
      emit(buf.toList())
      buf.clear()
    }
  }
  if (buf.isNotEmpty()) {
    emit(buf.toList())
  }
}
// unnamed ends here

// [[file:index.org::17701]]
/**
 * Collects values over time windows.
 * Note: Simplified implementation using periodic emission.
 */
suspend fun <T> Flow<T>.bufferTime(ms: Long): Flow<List<T>> = flow {
  val buf = mutableListOf<T>()
  var lastEmit = System.currentTimeMillis()
  
  collect { item ->
    buf.add(item)
    val now = System.currentTimeMillis()
    if (now - lastEmit >= ms) {
      if (buf.isNotEmpty()) {
        emit(buf.toList())
        buf.clear()
      }
      lastEmit = now
    }
  }
  
  if (buf.isNotEmpty()) {
    emit(buf.toList())
  }
}
// unnamed ends here

// [[file:index.org::18155]]
/**
 * Splits source into windows of specified size.
 * Simplified to return lists like buffer.
 */
fun <T> Flow<T>.window(size: Int): Flow<List<T>> = flow {
  val buf = mutableListOf<T>()
  collect { item ->
    buf.add(item)
    if (buf.size >= size) {
      emit(buf.toList())
      buf.clear()
    }
  }
  if (buf.isNotEmpty()) {
    emit(buf.toList())
  }
}
// unnamed ends here

// [[file:index.org::18662]]
/**
 * Prefetches values from source.
 * Note: Kotlin Flow buffer() already provides buffering behavior.
 */
fun <T> Flow<T>.eager(bufferSize: Int): Flow<T> =
  this

/**
 * Pre-fetches values immediately on creation.
 * In Kotlin, flows are cold, so this uses shareIn for hot behavior.
 */
fun <T> Flow<T>.eagerNow(bufferSize: Int, scope: kotlinx.coroutines.CoroutineScope): Flow<T> =
  shareIn(scope, kotlinx.coroutines.flow.SharingStarted.Eagerly, bufferSize.coerceAtLeast(0))
// unnamed ends here

// [[file:index.org::19722]]
/**
 * A multicasting subject that replays buffered values to new subscribers.
 * Note: Simplified using SharedFlow with replay.
 */
class ReplaySubject<T>(bufferSize: Int = Int.MAX_VALUE) {
  private val _flow = MutableSharedFlow<T>(
    replay = bufferSize,
    extraBufferCapacity = bufferSize
  )
  
  val flow: SharedFlow<T> = _flow.asSharedFlow()
  
  suspend fun next(value: T) {
    _flow.emit(value)
  }
  
  fun getBuffer(): List<T> = _flow.replayCache.toList()
  
  val subscriberCount: Int get() = _flow.subscriptionCount.value
}
// unnamed ends here

// [[file:index.org::20098]]
/**
 * Creates a replay wrapper for a flow.
 * Note: In Kotlin, use shareIn for multicasting.
 */
fun <T> Flow<T>.replay(
  bufferSize: Int,
  scope: kotlinx.coroutines.CoroutineScope
): SharedFlow<T> =
  shareIn(scope, kotlinx.coroutines.flow.SharingStarted.Lazily, bufferSize)

/**
 * Shares a flow without buffering.
 */
fun <T> Flow<T>.share(
  scope: kotlinx.coroutines.CoroutineScope
): SharedFlow<T> =
  shareIn(scope, kotlinx.coroutines.flow.SharingStarted.Lazily, 0)
// unnamed ends here

// [[file:index.org::20492]]
/**
 * Creates a factory that produces independent copies of a buffered flow.
 * Note: In Kotlin, SharedFlow subscribers share the same stream.
 */
fun <T> replayFactory(
  bufferSize: Int,
  source: Flow<T>,
  scope: kotlinx.coroutines.CoroutineScope
): () -> SharedFlow<T> {
  val shared = source.shareIn(scope, kotlinx.coroutines.flow.SharingStarted.Eagerly, bufferSize)
  return { shared }
}
// unnamed ends here
