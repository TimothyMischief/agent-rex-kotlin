// This file is auto-generated by organjsm tangle. Do not edit directly.
// Source: index.org

// [[file:index.org::641]]
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.channels.*
import kotlinx.coroutines.test.*
import kotlin.test.*

class JustTest {
  @Test
  fun `just emits single value and completes`() = runTest {
    val values = just(42).toList()
    assertEquals(listOf(42), values)
  }
  
  @Test
  fun `of is alias for just`() = runTest {
    val values = of("hello").toList()
    assertEquals(listOf("hello"), values)
  }
}
// unnamed ends here

// [[file:index.org::1061]]
class FromDeferredTest {
  @Test
  fun `fromDeferred emits resolved value`() = runTest {
    val deferred = async { 42 }
    val values = fromDeferred(deferred).toList()
    assertEquals(listOf(42), values)
  }
  
  @Test
  fun `fromSuspend emits computed value`() = runTest {
    val values = fromSuspend {
      delay(1)
      "computed"
    }.toList()
    assertEquals(listOf("computed"), values)
  }
}
// unnamed ends here

// [[file:index.org::1390]]
class FromTest {
  @Test
  fun `from emits all values from list`() = runTest {
    val values = from(listOf(1, 2, 3)).toList()
    assertEquals(listOf(1, 2, 3), values)
  }
  
  @Test
  fun `from handles empty list`() = runTest {
    val values = from(emptyList<Int>()).toList()
    assertEquals(emptyList(), values)
  }
  
  @Test
  fun `from works with sequences`() = runTest {
    val values = from(sequenceOf(4, 5, 6)).toList()
    assertEquals(listOf(4, 5, 6), values)
  }
}
// unnamed ends here

// [[file:index.org::1752]]
class PeriodicTest {
  @Test
  fun `periodic emits at intervals`() = runTest {
    val values = periodic(10).take(3).toList()
    assertEquals(listOf(Unit, Unit, Unit), values)
    assertEquals(3, values.size)
  }
}
// unnamed ends here

// [[file:index.org::2003]]
class EmptyTest {
  @Test
  fun `empty completes immediately`() = runTest {
    val values = empty<Int>().toList()
    assertEquals(emptyList(), values)
  }
}
// unnamed ends here

// [[file:index.org::2233]]
class NeverTest {
  @Test
  fun `never does not complete`() = runTest {
    // never() should timeout since it never emits
    try {
      withTimeout(10) {
        never<Int>().collect { }
      }
      fail("Should have timed out")
    } catch (e: TimeoutCancellationException) {
      // Expected
    }
  }
}
// unnamed ends here

// [[file:index.org::2524]]
class IterateTest {
  @Test
  fun `iterate generates sequence`() = runTest {
    val values = iterate(1) { it * 2 }.take(5).toList()
    assertEquals(listOf(1, 2, 4, 8, 16), values)
  }
  
  @Test
  fun `iterate with addition`() = runTest {
    val values = iterate(0) { it + 1 }.take(4).toList()
    assertEquals(listOf(0, 1, 2, 3), values)
  }
}
// unnamed ends here

// [[file:index.org::2921]]
class UnfoldTest {
  @Test
  fun `unfold generates values until done`() = runTest {
    val values = unfold(1) { n ->
      UnfoldResult(
        value = n,
        nextSeed = n + 1,
        done = n > 3
      )
    }.toList()
    assertEquals(listOf(1, 2, 3), values)
  }
  
  @Test
  fun `unfold stops immediately when done`() = runTest {
    val values = unfold(0) { _ ->
      UnfoldResult(
        value = 999,
        nextSeed = 0,
        done = true
      )
    }.toList()
    assertEquals(emptyList(), values)
  }
}
// unnamed ends here

// [[file:index.org::3296]]
class StartWithTest {
  @Test
  fun `startWith prepends value`() = runTest {
    val values = startWith(0, from(listOf(1, 2, 3))).toList()
    assertEquals(listOf(0, 1, 2, 3), values)
  }
  
  @Test
  fun `startWith works with empty stream`() = runTest {
    val values = startWith(42, empty()).toList()
    assertEquals(listOf(42), values)
  }
}
// unnamed ends here

// [[file:index.org::3609]]
class ConcatTest {
  @Test
  fun `concat joins streams`() = runTest {
    val values = concat(
      from(listOf(1, 2)),
      from(listOf(3, 4))
    ).toList()
    assertEquals(listOf(1, 2, 3, 4), values)
  }
  
  @Test
  fun `concat with empty first stream`() = runTest {
    val values = concat2(empty(), from(listOf(5, 6))).toList()
    assertEquals(listOf(5, 6), values)
  }
  
  @Test
  fun `concat multiple streams`() = runTest {
    val values = concat(
      from(listOf(1)),
      from(listOf(2, 3)),
      from(listOf(4))
    ).toList()
    assertEquals(listOf(1, 2, 3, 4), values)
  }
}
// unnamed ends here

// [[file:index.org::4515]]
class MapTest {
  @Test
  fun `map transforms values`() = runTest {
    val values = from(listOf(1, 2, 3)).map { it * 2 }.toList()
    assertEquals(listOf(2, 4, 6), values)
  }
  
  @Test
  fun `mapAsync with suspend function`() = runTest {
    val values = from(listOf(1, 2, 3)).mapAsync {
      delay(1)
      it * 10
    }.toList()
    assertEquals(listOf(10, 20, 30), values)
  }
}
// unnamed ends here

// [[file:index.org::4891]]
class ConstantTest {
  @Test
  fun `constant replaces all values`() = runTest {
    val values = from(listOf(1, 2, 3))
      .constant("x")
      .toList()
    assertEquals(listOf("x", "x", "x"), values)
  }
  
  @Test
  fun `constant empty stream`() = runTest {
    val values = from(emptyList<Int>())
      .constant(42)
      .toList()
    assertEquals(emptyList(), values)
  }
}
// unnamed ends here

// [[file:index.org::5223]]
class ScanTest {
  @Test
  fun `scan accumulates with seed`() = runTest {
    val values = from(listOf(1, 2, 3))
      .scanWithSeed(0) { acc, x -> acc + x }
      .toList()
    assertEquals(listOf(0, 1, 3, 6), values)
  }
  
  @Test
  fun `scan product`() = runTest {
    val values = from(listOf(2, 3, 4))
      .scanWithSeed(1) { acc, x -> acc * x }
      .toList()
    assertEquals(listOf(1, 2, 6, 24), values)
  }
  
  @Test
  fun `scan empty stream`() = runTest {
    val values = from(emptyList<Int>())
      .scanWithSeed(100) { acc, x -> acc + x }
      .toList()
    assertEquals(listOf(100), values)
  }
}
// unnamed ends here

// [[file:index.org::5657]]
class TapTest {
  @Test
  fun `tap performs side effect`() = runTest {
    val sideEffects = mutableListOf<Int>()
    val values = tap({ sideEffects.add(it) }, from(listOf(1, 2, 3))).toList()
    assertEquals(listOf(1, 2, 3), values)
    assertEquals(listOf(1, 2, 3), sideEffects)
  }
}
// unnamed ends here

// [[file:index.org::5973]]
class AwaitTapTest {
  @Test
  fun `awaitTap awaits side effect`() = runTest {
    val sideEffects = mutableListOf<Int>()
    val values = awaitTap(
      { value ->
        kotlinx.coroutines.delay(5)
        sideEffects.add(value)
      },
      from(listOf(1, 2, 3))
    ).toList()
    assertEquals(listOf(1, 2, 3), values)
    assertEquals(listOf(1, 2, 3), sideEffects)
  }
}
// unnamed ends here

// [[file:index.org::6326]]
class ContinueWithTest {
  @Test
  fun `continueWith appends stream`() = runTest {
    val values = continueWith(
      { from(listOf(3, 4)) },
      from(listOf(1, 2))
    ).toList()
    assertEquals(listOf(1, 2, 3, 4), values)
  }
  
  @Test
  fun `continueWith is lazy`() = runTest {
    var called = false
    val values = continueWith(
      {
        called = true
        from(listOf(99))
      },
      from(listOf(1))
    ).toList()
    assertEquals(true, called)
    assertEquals(listOf(1, 99), values)
  }
}
// unnamed ends here

// [[file:index.org::6667]]
class ConcatAllTest {
  @Test
  fun `concatAll flattens stream of streams`() = runTest {
    val streamOfStreams = from(listOf(
      from(listOf(1, 2)),
      from(listOf(3, 4))
    ))
    val values = concatAll(streamOfStreams).toList()
    assertEquals(listOf(1, 2, 3, 4), values)
  }
}
// unnamed ends here

// [[file:index.org::6992]]
class ConcatMapTest {
  @Test
  fun `concatMap maps and concatenates`() = runTest {
    val values = concatMap(
      { x -> from(listOf(x * 10, x * 10 + 1)) },
      from(listOf(1, 2))
    ).toList()
    assertEquals(listOf(10, 11, 20, 21), values)
  }
  
  @Test
  fun `concatMap handles empty results`() = runTest {
    val values = concatMap(
      { x -> if (x > 1) from(listOf(x)) else empty() },
      from(listOf(1, 2, 3))
    ).toList()
    assertEquals(listOf(2, 3), values)
  }
}
// unnamed ends here

// [[file:index.org::7377]]
class FilterTest {
  @Test
  fun `filter keeps matching values`() = runTest {
    val values = from(listOf(1, 2, 3, 4, 5)).filter { it > 2 }.toList()
    assertEquals(listOf(3, 4, 5), values)
  }
  
  @Test
  fun `filter even numbers`() = runTest {
    val values = from(listOf(1, 2, 3, 4, 5, 6)).filter { it % 2 == 0 }.toList()
    assertEquals(listOf(2, 4, 6), values)
  }
  
  @Test
  fun `filterAsync with suspend predicate`() = runTest {
    val values = from(listOf(1, 2, 3, 4)).filterAsync {
      delay(1)
      it % 2 == 0
    }.toList()
    assertEquals(listOf(2, 4), values)
  }
}
// unnamed ends here

// [[file:index.org::7951]]
class SkipRepeatsTest {
  @Test
  fun `skipRepeats removes consecutive duplicates`() = runTest {
    val values = skipRepeats(from(listOf(1, 1, 2, 2, 3, 1, 1))).toList()
    assertEquals(listOf(1, 2, 3, 1), values)
  }
  
  @Test
  fun `skipRepeats handles single value`() = runTest {
    val values = skipRepeats(from(listOf(42))).toList()
    assertEquals(listOf(42), values)
  }
  
  @Test
  fun `skipRepeatsWith uses custom equality`() = runTest {
    val values = skipRepeatsWith(
      { a, b -> a.lowercase() == b.lowercase() },
      from(listOf("A", "a", "B", "b"))
    ).toList()
    assertEquals(listOf("A", "B"), values)
  }
}
// unnamed ends here

// [[file:index.org::8391]]
class TakeTest {
  @Test
  fun `take first n values`() = runTest {
    val values = from(listOf(1, 2, 3, 4, 5)).take(2).toList()
    assertEquals(listOf(1, 2), values)
  }
  
  @Test
  fun `take more than available`() = runTest {
    val values = from(listOf(1, 2)).take(10).toList()
    assertEquals(listOf(1, 2), values)
  }
  
  @Test
  fun `take zero throws`() = runTest {
    // Kotlin's Flow.take requires count >= 1
    assertFailsWith<IllegalArgumentException> {
      from(listOf(1, 2, 3)).take(0).toList()
    }
  }
}
// unnamed ends here

// [[file:index.org::8732]]
class SkipTest {
  @Test
  fun `skip first n values`() = runTest {
    val values = from(listOf(1, 2, 3, 4, 5)).skip(2).toList()
    assertEquals(listOf(3, 4, 5), values)
  }
  
  @Test
  fun `skip zero`() = runTest {
    val values = from(listOf(1, 2, 3)).skip(0).toList()
    assertEquals(listOf(1, 2, 3), values)
  }
  
  @Test
  fun `skip more than available`() = runTest {
    val values = from(listOf(1, 2)).skip(5).toList()
    assertEquals(emptyList(), values)
  }
}
// unnamed ends here

// [[file:index.org::9110]]
class SliceTest {
  @Test
  fun `slice extracts range`() = runTest {
    val values = slice(2, 5, from(listOf(0, 1, 2, 3, 4, 5))).toList()
    assertEquals(listOf(2, 3, 4), values)
  }
  
  @Test
  fun `slice empty range`() = runTest {
    val values = slice(2, 2, from(listOf(0, 1, 2, 3, 4))).toList()
    assertEquals(emptyList(), values)
  }
  
  @Test
  fun `slice beyond length`() = runTest {
    val values = slice(1, 10, from(listOf(0, 1, 2))).toList()
    assertEquals(listOf(1, 2), values)
  }
}
// unnamed ends here

// [[file:index.org::9503]]
class TakeWhileTest {
  @Test
  fun `takeWhile takes while true`() = runTest {
    val values = takeWhile({ it < 4 }, from(listOf(1, 2, 3, 4, 2, 1))).toList()
    assertEquals(listOf(1, 2, 3), values)
  }
  
  @Test
  fun `takeWhile all pass`() = runTest {
    val values = takeWhile({ true }, from(listOf(1, 2, 3))).toList()
    assertEquals(listOf(1, 2, 3), values)
  }
  
  @Test
  fun `takeWhile none pass`() = runTest {
    val values = takeWhile({ false }, from(listOf(1, 2, 3))).toList()
    assertEquals(emptyList(), values)
  }
}
// unnamed ends here

// [[file:index.org::9899]]
class SkipWhileTest {
  @Test
  fun `skipWhile skips while true`() = runTest {
    val values = skipWhile({ it < 3 }, from(listOf(1, 2, 3, 4, 2, 1))).toList()
    assertEquals(listOf(3, 4, 2, 1), values)
  }
  
  @Test
  fun `skipWhile all fail`() = runTest {
    val values = skipWhile({ false }, from(listOf(1, 2, 3))).toList()
    assertEquals(listOf(1, 2, 3), values)
  }
  
  @Test
  fun `skipWhile all pass`() = runTest {
    val values = skipWhile({ true }, from(listOf(1, 2, 3))).toList()
    assertEquals(emptyList(), values)
  }
}
// unnamed ends here

// [[file:index.org::10294]]
class TakeUntilTest {
  @Test
  fun `takeUntil takes until match`() = runTest {
    val values = takeUntil({ it == 3 }, from(listOf(1, 2, 3, 4, 5))).toList()
    assertEquals(listOf(1, 2), values)
  }
  
  @Test
  fun `takeUntil never matches`() = runTest {
    val values = takeUntil({ false }, from(listOf(1, 2, 3))).toList()
    assertEquals(listOf(1, 2, 3), values)
  }
  
  @Test
  fun `takeUntil first matches`() = runTest {
    val values = takeUntil({ it == 1 }, from(listOf(1, 2, 3))).toList()
    assertEquals(emptyList(), values)
  }
}
// unnamed ends here

// [[file:index.org::10733]]
class DelayTest {
  @Test
  fun `delay delays each emission`() = runTest {
    // Use virtual time checking instead of wall clock
    val values = from(listOf(1, 2, 3))
      .delayEach(20)
      .toList()
    assertEquals(listOf(1, 2, 3), values)
    // Virtual time should have advanced by ~60ms
    assertTrue(testScheduler.currentTime >= 60)
  }
  
  @Test
  fun `delay empty stream`() = runTest {
    val values = from(emptyList<Int>())
      .delayEach(100)
      .toList()
    assertEquals(emptyList(), values)
  }
}
// unnamed ends here

// [[file:index.org::11161]]
class DebounceTest {
  @Test
  fun `debounce emits only settled values`() = runTest {
    val values = flow {
      emit(1)
      delay(10)
      emit(2)
      delay(10)
      emit(3)
      delay(50) // Let it settle
    }.debounceEach(30).toList()
    // Only the last value should be emitted
    assertEquals(listOf(3), values)
  }
  
  @Test
  fun `debounce with large gaps emits multiple values`() = runTest {
    val values = flow {
      emit(1)
      delay(50)
      emit(2)
    }.debounceEach(20).toList()
    // Both should emit since delay > debounce time
    assertEquals(listOf(1, 2), values)
  }
}
// unnamed ends here

// [[file:index.org::11845]]
class ThrottleTest {
  @Test
  fun `throttle leading emits first value`() = runTest {
    val values = from(listOf(1, 2, 3, 4, 5))
      .throttleEach(100, ThrottleOptions.leadingOnly())
      .toList()
    // First value should be emitted immediately
    assertTrue(values.isNotEmpty())
    assertEquals(1, values[0])
  }
  
  @Test
  fun `throttle trailing emits last value`() = runTest {
    val values = from(listOf(1, 2, 3))
      .throttleEach(100, ThrottleOptions.trailingOnly())
      .toList()
    // Last value should be emitted as trailing
    assertTrue(values.isNotEmpty())
  }
  
  @Test
  fun `throttle empty stream`() = runTest {
    val values = from(emptyList<Int>())
      .throttleEach(100)
      .toList()
    assertEquals(emptyList(), values)
  }
}
// unnamed ends here

// [[file:index.org::12432]]
class RecoverWithTest {
  @Test
  fun `recoverWith recovers from error`() = runTest {
    val failing = flow {
      emit(1)
      throw IllegalStateException("oops")
    }
    
    val values = failing
      .recoverWith { from(listOf(99)) }
      .toList()
    
    assertEquals(listOf(1, 99), values)
  }
  
  @Test
  fun `recoverWith passes through success`() = runTest {
    val values = from(listOf(1, 2, 3))
      .recoverWith { from(listOf(99)) }
      .toList()
    
    assertEquals(listOf(1, 2, 3), values)
  }
}
// unnamed ends here

// [[file:index.org::12986]]
class ThrowErrorTest {
  @Test
  fun `throwError creates failing stream`() = runTest {
    val error = IllegalStateException("test error")
    assertFailsWith<IllegalStateException> {
      throwError<Int>(error).collect()
    }
  }
}
// unnamed ends here

// [[file:index.org::13507]]
class RetryTest {
  @Test
  fun `retry retries until success`() = runTest {
    var attempts = 0
    
    val values = retry(RetryOptions(maxAttempts = 3)) {
      flow {
        attempts++
        if (attempts < 3) {
          throw IllegalStateException("fail $attempts")
        }
        emit(attempts)
      }
    }.toList()
    
    assertEquals(3, attempts)
    assertEquals(listOf(3), values)
  }
  
  @Test
  fun `retry throws after max attempts`() = runTest {
    var attempts = 0
    
    assertFailsWith<IllegalStateException> {
      retry(RetryOptions(maxAttempts = 2)) {
        flow<Int> {
          attempts++
          throw IllegalStateException("always fails")
        }
      }.collect()
    }
    
    assertEquals(2, attempts)
  }
}
// unnamed ends here

// [[file:index.org::14193]]
class MergeTest {
  @Test
  fun `merge combines multiple flows`() = runTest {
    val f1 = from(listOf(1, 3, 5))
    val f2 = from(listOf(2, 4, 6))
    val values = merge(f1, f2).toList()
    // Order may vary due to concurrency, check all present
    assertEquals(6, values.size)
    assertTrue(values.contains(1))
    assertTrue(values.contains(6))
  }
  
  @Test
  fun `merge from list`() = runTest {
    val flows = listOf(from(listOf(1, 2)), from(listOf(3, 4)))
    val values = merge(flows).toList()
    assertEquals(4, values.size)
  }
}
// unnamed ends here

// [[file:index.org::14580]]
class MergeAllTest {
  @Test
  fun `mergeAll flattens stream of streams`() = runTest {
    val streams = from(listOf(
      from(listOf(1, 2)),
      from(listOf(3, 4))
    ))
    
    val values = streams.mergeAll().toList()
    // Order may vary, check all present
    assertEquals(setOf(1, 2, 3, 4), values.toSet())
  }
  
  @Test
  fun `mergeAll handles empty outer stream`() = runTest {
    val streams = from(emptyList<Flow<Int>>())
    val values = streams.mergeAll().toList()
    assertEquals(emptyList(), values)
  }
}
// unnamed ends here

// [[file:index.org::15005]]
class ChainTest {
  @Test
  fun `chain flattens inner flows`() = runTest {
    val values = from(listOf(1, 2))
      .chain { x -> from(listOf(x * 10, x * 10 + 1)) }
      .toList()
    // Concurrent, so check for all values
    assertEquals(setOf(10, 11, 20, 21), values.toSet())
  }
  
  @Test
  fun `flatMap is alias for chain`() = runTest {
    val values = from(listOf(1, 2))
      .flatMap { x -> from(listOf(x, x * 2)) }
      .toList()
      .sorted()
    assertEquals(listOf(1, 2, 2, 4), values)
  }
}
// unnamed ends here

// [[file:index.org::15541]]
class SwitchMapTest {
  @Test
  fun `switchMap cancels previous inner stream`() = runTest {
    val values = from(listOf(1, 2, 3))
      .switchMap { x -> from(listOf(x * 10)) }
      .toList()
    // With fast synchronous streams, may see all or just last
    assertTrue(values.isNotEmpty())
  }
  
  @Test
  fun `switchMap completes when outer and inner complete`() = runTest {
    val values = from(listOf(1))
      .switchMap { x -> from(listOf(x, x * 2)) }
      .toList()
    assertEquals(listOf(1, 2), values)
  }
}
// unnamed ends here

// [[file:index.org::15991]]
class LatestTest {
  @Test
  fun `latest combines two flows`() = runTest {
    val f1 = from(listOf(1, 2))
    val f2 = from(listOf("a", "b"))
    val values = latest(f1, f2).toList()
    // Should emit tuples after both have values
    assertTrue(values.isNotEmpty())
    values.forEach { (num, str) ->
      assertTrue(num is Int)
      assertTrue(str is String)
    }
  }
}
// unnamed ends here

// [[file:index.org::16316]]
class ApplyLatestTest {
  @Test
  fun `applyLatest applies function to value`() = runTest {
    val fns = from(listOf({ x: Int -> x * 2 }, { x: Int -> x * 3 }))
    val vals = from(listOf(10, 20))
    val values = applyLatest(fns, vals).toList()
    assertTrue(values.isNotEmpty())
    values.forEach { assertTrue(it is Int) }
  }
}
// unnamed ends here

// [[file:index.org::16676]]
class UntilStreamTest {
  @Test
  fun `untilStream stops when stop emits`() = runTest {
    val source = from(listOf(1, 2, 3, 4, 5))
    val stop = from(listOf(Unit))
    val values = source.untilStream(stop).toList()
    assertTrue(values.size <= 5)
  }
}
// unnamed ends here

// [[file:index.org::17045]]
class SinceStreamTest {
  @Test
  fun `sinceStream waits for start`() = runTest {
    val source = from(listOf(1, 2, 3, 4))
    val start = from(listOf(Unit))
    val values = source.sinceStream(start).toList()
    assertTrue(values.isNotEmpty())
  }
}
// unnamed ends here

// [[file:index.org::17391]]
class BufferTest {
  @Test
  fun `buffer collects into fixed-size lists`() = runTest {
    val values = from(listOf(1, 2, 3, 4, 5)).buffer(2).toList()
    assertEquals(listOf(listOf(1, 2), listOf(3, 4), listOf(5)), values)
  }
}
// unnamed ends here

// [[file:index.org::17772]]
class BufferTimeTest {
  @Test
  fun `bufferTime collects over time windows`() = runTest {
    val source = from(listOf(1, 2, 3, 4))
    val values = source.bufferTime(100).toList()
    assertTrue(values.flatten() == listOf(1, 2, 3, 4))
  }
}
// unnamed ends here

// [[file:index.org::18219]]
class WindowTest {
  @Test
  fun `window splits into fixed-size groups`() = runTest {
    val values = from(listOf(1, 2, 3, 4, 5)).window(2).toList()
    assertEquals(listOf(listOf(1, 2), listOf(3, 4), listOf(5)), values)
  }
}
// unnamed ends here

// [[file:index.org::18722]]
class EagerTest {
  @Test
  fun `eager prefetches values`() = runTest {
    val values = from(listOf(1, 2, 3)).eager(2).toList()
    assertEquals(listOf(1, 2, 3), values)
  }
}
// unnamed ends here

// [[file:index.org::19789]]
class ReplaySubjectTest {
  @Test
  fun `ReplaySubject replays buffered values`() = runTest {
    val subject = ReplaySubject<Int>(2)
    subject.next(1)
    subject.next(2)
    subject.next(3)
    
    val values = subject.flow.take(2).toList()
    // Should get last 2 values (2, 3)
    assertTrue(values.contains(2))
    assertTrue(values.contains(3))
  }
}
// unnamed ends here

// [[file:index.org::20162]]
class ReplayShareTest {
  @Test
  fun `replay multicasts with buffer`() = runTest {
    val source = from(listOf(1, 2, 3))
    val replayed = source.shareIn(backgroundScope, SharingStarted.Eagerly, 2)
    
    // Give it time to collect
    delay(10)
    val values = replayed.replayCache
    assertEquals(listOf(2, 3), values) // Only last 2 due to buffer size
  }
  
  @Test
  fun `share multicasts without buffer`() = runTest {
    val source = from(listOf(1, 2, 3))
    val shared = source.shareIn(backgroundScope, SharingStarted.Eagerly, 0)
    
    // With no buffer and eager start, values are already emitted
    delay(10)
    assertEquals(0, shared.replayCache.size)
  }
}
// unnamed ends here

// [[file:index.org::20551]]
class ReplayFactoryTest {
  @Test
  fun `replayFactory creates stream copies`() = runTest {
    val factory = replayFactory(2, from(listOf(1, 2, 3)), backgroundScope)
    
    // Give it time to collect
    delay(10)
    
    // Both copies should see the same buffered values
    val cache1 = factory().replayCache
    val cache2 = factory().replayCache
    
    assertEquals(cache1, cache2)
    assertTrue(cache1.isNotEmpty())
  }
}
// unnamed ends here
